import getopt
import numpy as np
import os
import sys


# constants
DEV = False
opts, _ = getopt.getopt(sys.argv[1:], "d", [])
for opt, _ in opts:
    if opt == '-d':
        DEV = True


if DEV:
    CORRECT_PATH = "../data/d/small-clean.txt"
    INCORRECT_PATH = "../data/d/small-corrupt.txt"
else:
    CORRECT_PATH = "../data/d/clean.txt"
    INCORRECT_PATH = "../data/d/corrupt.txt"

MAX_CHAR_LEN = 8
BOS = '∫'
EOS = 'µ'
PAD = 'ƒ'


input_vocab = set()
input_vocab.add(BOS)
input_vocab.add(EOS)
input_vocab.add(PAD)

c_lines = []
if os.path.isfile(CORRECT_PATH):
    with open(CORRECT_PATH, "r", encoding="utf-8") as f:
        c_lines = [line.lower() for line in f.read().split("\n")]
        for line in c_lines:
            for char in line:
                input_vocab.add(char)

i_lines = []
if os.path.isfile(INCORRECT_PATH):
    with open(INCORRECT_PATH, "r", encoding="utf-8") as f:
        i_lines = [line.lower() for line in f.read().split("\n")]
        for line in i_lines:
            for char in line:
                input_vocab.add(char)


char_idx = dict(zip(sorted(input_vocab), [i for i, _ in enumerate(sorted(input_vocab))]))
idx_char = {v: k for k, v in char_idx.items()}

texts = []

encoder_input = []
for line in i_lines:
    tmp = []
    for i in range(len(line)):
        char_list = line[i:i + MAX_CHAR_LEN]
        if len(char_list) < MAX_CHAR_LEN:
            t = char_list + PAD * (MAX_CHAR_LEN - len(char_list))
            tmp.append(list(t))
            continue
        tmp.append(list(char_list))
    encoder_input.append(tmp)

decoder_input = []
decoder_output = []
flag = False
for line in c_lines:
    tmp = []
    for i in range(len(line)):
        if i == 0:
            flag = True
            continue

        di_char_list = BOS + line[i:i + MAX_CHAR_LEN - 1]
        do_char_list = line[i:i + MAX_CHAR_LEN - 1] + EOS

        if len(di_char_list) < MAX_CHAR_LEN:
            t = di_char_list + PAD * (MAX_CHAR_LEN - len(di_char_list))
            tmp.append(list(t))
        else:
            tmp.append(list(di_char_list))
    decoder_input.append(tmp)

print(encoder_input[0], '\n')
print(decoder_input[0], '\n')
print(decoder_output[0], '\n')
exit()

# adding 4 for BOS + ' ' + ' ' + EOS
max_line_len = max([max([len(line) + 4 for line in c_lines]),
                   max([len(line) + 4 for line in c_lines])])

while max_line_len % 4 != 0:
    max_line_len += max_line_len % 4

for i in range(len(c_lines)):
    tmp = PAD * (max_line_len - len(c_lines[i]) - 4)
    c_lines[i] = tmp + c_lines[i]

c_lines = [BOS + ' ' + line + ' ' + EOS for line in c_lines]

data_shape = (len(c_lines), max_line_len, len(char_idx))

c_data = np.zeros(data_shape)
for li, line in enumerate(c_lines):
    for ci, char in enumerate(line):
        c_data[li][ci][char_idx[char]] = 1.


i_data = np.zeros(data_shape)
for li, line in enumerate(i_lines):
    for ci, char in enumerate(line):
        i_data[li][ci][char_idx[char]] = 1.

with open('input.npy', 'wb') as f:
    np.save(f, i_data)

with open('output.npy', 'wb') as f:
    np.save(f, c_data)
