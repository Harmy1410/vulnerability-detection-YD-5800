import const as c
import json
import numpy as np
import os
from tensorflow.keras import Input
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.models import Model, load_model
from tensorflow.keras.utils import plot_model


def load_npy(path):
    with open(path, 'rb') as f:
        data = np.load(f)
    return data


def inference_translater(input):

    encoder_states = encoder_model.predict(input)
    # encoder_states = [encoder_states[0], encoder_states[1]]

    output_seq = np.array([[54, 0, 0, 0]] * encoder_inputs_shape[0])
    a = np.zeros((1, 384, 4))
    b = np.zeros((1, 384, 4))
    i = [[output_seq] + a + b]
    # print([output_seq] + encoder_states)
    # exit()
    for _ in range(5):
        output_tokens, h, c = decoder_model.predict(output_seq + a.any() + b.any())

    return output_seq


train_encoder_input = load_npy(c.ENCODER_INPUT_TRAIN_PATH)
train_decoder_input = load_npy(c.DECODER_INPUT_TRAIN_PATH)
train_decoder_output = load_npy(c.DECODER_OUTPUT_TRAIN_PATH)

# val_encoder_input = load_npy(c.ENCODER_INPUT_VAL_PATH)
# val_decoder_input = load_npy(c.DECODER_INPUT_VAL_PATH)
# val_decoder_output = load_npy(c.DECODER_OUTPUT_VAL_PATH)

test_encoder_input = load_npy(c.ENCODER_INPUT_TEST_PATH)
test_decoder_input = load_npy(c.DECODER_INPUT_TEST_PATH)
test_decoder_output = load_npy(c.DECODER_OUTPUT_TEST_PATH)

encoder_inputs_shape = (train_encoder_input.shape[1], train_encoder_input.shape[2])
decoder_inputs_shape = ((train_decoder_input.shape[1]), train_decoder_input.shape[2])

# define training encoder
encoder_inputs = Input(shape=encoder_inputs_shape)
encoder = LSTM(c.UNITS, return_state=True)
encoder_outputs, state_h, state_c = encoder(encoder_inputs)
encoder_states = [state_h, state_c]

# define training decoder
decoder_inputs = Input(shape=decoder_inputs_shape)
decoder_lstm = LSTM(c.UNITS, return_sequences=True, return_state=True)
decoder_outputs, _, _ = decoder_lstm(decoder_inputs, initial_state=encoder_states)
decoder_dense = Dense(c.MAX_CHAR_LEN, activation='softmax')
decoder_outputs = decoder_dense(decoder_outputs)
model = Model([encoder_inputs, decoder_inputs], decoder_outputs)

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
model.summary()
if not os.path.isdir('saved-model'):
    model.fit(
        [train_encoder_input, train_decoder_input],
        train_decoder_output,
        epochs=c.EPOCH,
        validation_split=0.2
    )
    model.save('saved-model')
else:
    model = load_model('saved-model')

# inferance
# define inference encoder
encoder_model = Model(encoder_inputs, encoder_states)
encoder_model.summary()

# define inference decoder
decoder_state_input_h = Input(shape=(c.UNITS,))
decoder_state_input_c = Input(shape=(c.UNITS,))
decoder_states_inputs = [decoder_state_input_h, decoder_state_input_c]
decoder_outputs, state_h, state_c = decoder_lstm(
    decoder_inputs,
    initial_state=decoder_states_inputs
)
decoder_states = [state_h, state_c]
decoder_outputs = decoder_dense(decoder_outputs)
decoder_model = Model([decoder_inputs] + decoder_states_inputs,
                      [decoder_outputs] + decoder_states)
decoder_model.summary()

model_png = "model([e-di]-do).png"
encoder_png = "encoder_model.png"
decoder_png = "decoder_model.png"
if not os.path.isfile(model_png):
    plot_model(model, to_file=model_png, show_shapes=True, dpi=300)
if not os.path.isfile(encoder_png):
    plot_model(encoder_model, to_file=encoder_png, show_shapes=True, dpi=300)
if not os.path.isfile(decoder_png):
    plot_model(decoder_model, to_file=decoder_png, show_shapes=True, dpi=300)

inference_translater(test_encoder_input)
